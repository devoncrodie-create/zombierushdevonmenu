--// Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

--// State
local hitboxEnabled = false
local followEnabled = false
local flyEnabled = false
local noclipEnabled = false
local menuOpen = true
local lastClickTime = 0
local followSpeed = 0.15
local followOffset = 1
local hitboxSize = Vector3.new(20,20,20)
local flySpeed = 50

local char, humRoot, humanoid, bodyVel, bodyGyro

--// Handle respawn
local function onCharacterAdded(character)
    char = character
    humRoot = char:WaitForChild("HumanoidRootPart")
    humanoid = char:WaitForChild("Humanoid")

    if bodyVel then bodyVel:Destroy(); bodyVel=nil end
    if bodyGyro then bodyGyro:Destroy(); bodyGyro=nil end
end

char = player.Character or player.CharacterAdded:Wait()
onCharacterAdded(char)
player.CharacterAdded:Connect(onCharacterAdded)

--// Remove old GUI
if playerGui:FindFirstChild("DevonsMenuGUI") then
    playerGui.DevonsMenuGUI:Destroy()
end

--// GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DevonsMenuGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Main frame
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 250, 0, 500)
frame.Position = UDim2.new(0.05,0,0.05,0)
frame.BackgroundColor3 = Color3.fromRGB(35,35,45)
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true
frame.Parent = screenGui

-- Title
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1,0,0,50)
title.BackgroundColor3 = Color3.fromRGB(50,50,70)
title.TextColor3 = Color3.fromRGB(255,255,255)
title.Font = Enum.Font.GothamBold
title.TextScaled = true
title.Text = "Devon's Menu (BETA)"
title.Parent = frame

-- Function to create buttons
local function createButton(text, posY)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0, 220, 0, 40)
    btn.Position = UDim2.new(0,15,0,posY)
    btn.BackgroundColor3 = Color3.fromRGB(200,50,50)
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    btn.Font = Enum.Font.Gotham
    btn.TextScaled = true
    btn.Text = text
    btn.Parent = frame
    return btn
end

-- Create buttons
local hitboxBtn = createButton("Hitbox: OFF", 70)
local followBtn = createButton("Follow: OFF", 120)
local flyBtn = createButton("Fly: OFF", 170)
local noclipBtn = createButton("NoClip: OFF", 220)

-- Slider function
local function createSlider(labelText, posY, minVal, maxVal, isFollowSpeed, isFollowOffset)
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0,220,0,30)
    label.Position = UDim2.new(0,15,0,posY)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255,255,255)
    label.Font = Enum.Font.Gotham
    label.TextScaled = true
    label.Text = labelText
    label.Parent = frame

    local sliderFrame = Instance.new("Frame")
    sliderFrame.Size = UDim2.new(0,220,0,20)
    sliderFrame.Position = UDim2.new(0,15,0,posY+30)
    sliderFrame.BackgroundColor3 = Color3.fromRGB(70,70,90)
    sliderFrame.Parent = frame

    local fill = Instance.new("Frame")
    fill.Size = UDim2.new(0,0,1,0)
    fill.BackgroundColor3 = Color3.fromRGB(0,200,255)
    fill.Parent = sliderFrame

    local knob = Instance.new("TextButton")
    knob.Size = UDim2.new(0,20,1,0)
    knob.Position = UDim2.new(0,0,0,0)
    knob.BackgroundColor3 = Color3.fromRGB(255,255,255)
    knob.Text = ""
    knob.Parent = sliderFrame
    knob.AutoButtonColor = false

    local dragging = false
    knob.MouseButton1Down:Connect(function()
        dragging = true
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    RunService.RenderStepped:Connect(function()
        if dragging then
            local mouseX = math.clamp(UserInputService:GetMouseLocation().X - sliderFrame.AbsolutePosition.X,0,sliderFrame.AbsoluteSize.X)
            fill.Size = UDim2.new(0,mouseX,1,0)
            knob.Position = UDim2.new(0,mouseX-10,0,0)
            local value = minVal + (mouseX/sliderFrame.AbsoluteSize.X)*(maxVal-minVal)
            if isFollowSpeed then
                followSpeed = value
                label.Text = "Follow Speed: "..string.format("%.2f",followSpeed)
            elseif isFollowOffset then
                followOffset = value
                label.Text = "Above Zombie: "..string.format("%.1f",followOffset)
            else
                hitboxSize = Vector3.new(value,value,value)
                label.Text = "Hitbox Size: "..string.format("%.1f",value)
            end
        end
    end)
end

-- Create sliders
createSlider("Follow Speed: 0.15", 280, 0.05, 0.55, true, false)
createSlider("Hitbox Size: 20", 340, 5, 55, false, false)
createSlider("Above Zombie: 1", 400, 1, 10, false, true)

--// Button logic
local function updateButton(btn, state, name)
    btn.Text = name..(state and ": ON" or ": OFF")
    btn.BackgroundColor3 = state and Color3.fromRGB(0,200,0) or Color3.fromRGB(200,50,50)
end

hitboxBtn.MouseButton1Click:Connect(function()
    hitboxEnabled = not hitboxEnabled
    updateButton(hitboxBtn, hitboxEnabled, "Hitbox")
end)
followBtn.MouseButton1Click:Connect(function()
    followEnabled = not followEnabled
    updateButton(followBtn, followEnabled, "Follow")
end)
flyBtn.MouseButton1Click:Connect(function()
    flyEnabled = not flyEnabled
    updateButton(flyBtn, flyEnabled, "Fly")
end)
noclipBtn.MouseButton1Click:Connect(function()
    noclipEnabled = not noclipEnabled
    updateButton(noclipBtn, noclipEnabled, "NoClip")
end)

--// Fly & noclip logic
local moveKeys = {W=false,A=false,S=false,D=false,Space=false,LeftShift=false}
UserInputService.InputBegan:Connect(function(input, gp)
    if not gp then
        if input.KeyCode == Enum.KeyCode.W then moveKeys.W = true end
        if input.KeyCode == Enum.KeyCode.A then moveKeys.A = true end
        if input.KeyCode == Enum.KeyCode.S then moveKeys.S = true end
        if input.KeyCode == Enum.KeyCode.D then moveKeys.D = true end
        if input.KeyCode == Enum.KeyCode.Space then moveKeys.Space = true end
        if input.KeyCode == Enum.KeyCode.LeftShift then moveKeys.LeftShift = true end
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then moveKeys.W = false end
    if input.KeyCode == Enum.KeyCode.A then moveKeys.A = false end
    if input.KeyCode == Enum.KeyCode.S then moveKeys.S = false end
    if input.KeyCode == Enum.KeyCode.D then moveKeys.D = false end
    if input.KeyCode == Enum.KeyCode.Space then moveKeys.Space = false end
    if input.KeyCode == Enum.KeyCode.LeftShift then moveKeys.LeftShift = false end
end)

RunService.RenderStepped:Connect(function()
    if char then
        -- NoClip
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = not (noclipEnabled)
            end
        end

        -- Fly
        if flyEnabled and humRoot then
            if not bodyVel then
                bodyVel = Instance.new("BodyVelocity")
                bodyVel.MaxForce = Vector3.new(1e5,1e5,1e5)
                bodyVel.Parent = humRoot
            end
            if not bodyGyro then
                bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(1e5,1e5,1e5)
                bodyGyro.Parent = humRoot
            end

            local cam = workspace.CurrentCamera
            local look = cam.CFrame.LookVector
            local right = cam.CFrame.RightVector
            local direction = Vector3.new()
            if moveKeys.W then direction += look end
            if moveKeys.S then direction -= look end
            if moveKeys.A then direction -= right end
            if moveKeys.D then direction += right end
            if moveKeys.Space then direction += Vector3.new(0,1,0) end
            if moveKeys.LeftShift then direction -= Vector3.new(0,1,0) end
            if direction.Magnitude > 0 then direction = direction.Unit * flySpeed end
            bodyVel.Velocity = direction
            bodyGyro.CFrame = CFrame.new(humRoot.Position, humRoot.Position + cam.CFrame.LookVector)
        else
            if bodyVel then bodyVel:Destroy(); bodyVel=nil end
            if bodyGyro then bodyGyro:Destroy(); bodyGyro=nil end
        end
    end
end)

--// Follow logic
local zombieStorage = workspace:WaitForChild("Zombie Storage")
RunService.RenderStepped:Connect(function()
    if followEnabled and humRoot then
        local zombies = zombieStorage:GetChildren()
        local closestZombie, closestDist = nil, math.huge
        for _, z in ipairs(zombies) do
            local hrp = z:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (hrp.Position - humRoot.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestZombie = hrp
                end
            end
        end
        if closestZombie then
            humRoot.CFrame = humRoot.CFrame:Lerp(CFrame.new(closestZombie.Position + Vector3.new(0, followOffset, 0)), followSpeed)
        end
    end
end)

--// Hitbox logic
local function updateHitbox(zombie)
    local hrp = zombie:FindFirstChild("HumanoidRootPart")
    local hum = zombie:FindFirstChildWhichIsA("Humanoid")
    if hrp and hum then
        if hitboxEnabled then
            local hb = zombie:FindFirstChild("ZombieHitbox")
            if not hb then
                hb = Instance.new("Part")
                hb.Name = "ZombieHitbox"
                hb.Anchored = true
                hb.CanCollide = false
                hb.Transparency = 0.5
                hb.BrickColor = BrickColor.new("Really red")
                hb.Parent = zombie
                hb.Touched:Connect(function(hit)
                    if hit.Parent:FindFirstChildWhichIsA("Tool") then
                        hum:TakeDamage(1)
                    end
                end)
            end
            hb.Size = hitboxSize
            hb.CFrame = hrp
