--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local zombieStorage = workspace:WaitForChild("Zombie Storage")

--// State
local hitboxEnabled = false
local followEnabled = false
local flyEnabled = false
local noclipEnabled = false
local menuOpen = true
local lastClickTime = 0
local followSpeed = 0.15
local followOffset = 1
local flySpeed = 50
local hitboxSize = Vector3.new(20,20,20)

local char, humRoot, humanoid, bodyVel, bodyGyro

--// Handle respawn
local function onCharacterAdded(character)
    char = character
    humRoot = char:WaitForChild("HumanoidRootPart")
    humanoid = char:WaitForChild("Humanoid")
    if bodyVel then bodyVel:Destroy(); bodyVel=nil end
    if bodyGyro then bodyGyro:Destroy(); bodyGyro=nil end
end

char = player.Character or player.CharacterAdded:Wait()
onCharacterAdded(char)
player.CharacterAdded:Connect(onCharacterAdded)

--// GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ZombieMenuGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 200, 0, 400)
frame.Position = UDim2.new(0.05,0,0.05,0)
frame.BackgroundColor3 = Color3.fromRGB(50,50,50)
frame.BorderSizePixel = 0
frame.Parent = screenGui
frame.Active = true
frame.Draggable = true

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1,0,0,30)
titleLabel.Position = UDim2.new(0,0,0,0)
titleLabel.BackgroundColor3 = Color3.fromRGB(80,80,80)
titleLabel.TextColor3 = Color3.new(1,1,1)
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextScaled = true
titleLabel.Text = "Devon's Menu (BETA)"
titleLabel.Parent = frame
titleLabel.Active = true

--// Buttons
local function createButton(name, posY)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0,180,0,40)
    btn.Position = UDim2.new(0,10,0,posY)
    btn.BackgroundColor3 = Color3.fromRGB(200,0,0)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Text = name
    btn.Parent = frame
    return btn
end

local hitboxButton = createButton("Hitbox: OFF", 40)
local followButton = createButton("Follow: OFF", 90)
local flyButton = createButton("Fly: OFF", 140)
local noclipButton = createButton("NoClip: OFF", 190)

--// Slider
local function createSlider(labelText, posY, minVal, maxVal)
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0,180,0,20)
    label.Position = UDim2.new(0,10,0,posY)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.new(1,1,1)
    label.Text = labelText
    label.Parent = frame

    local slider = Instance.new("Frame")
    slider.Size = UDim2.new(0,180,0,20)
    slider.Position = UDim2.new(0,10,0,posY+20)
    slider.BackgroundColor3 = Color3.fromRGB(100,100,100)
    slider.Parent = frame

    local fill = Instance.new("Frame")
    fill.Size = UDim2.new(0,0,1,0)
    fill.BackgroundColor3 = Color3.fromRGB(0,200,0)
    fill.Parent = slider

    local knob = Instance.new("TextButton")
    knob.Size = UDim2.new(0,20,1,0)
    knob.Position = UDim2.new(0,0,0,0)
    knob.BackgroundColor3 = Color3.fromRGB(255,255,255)
    knob.Text = ""
    knob.Parent = slider
    knob.AutoButtonColor = false

    local dragging = false
    local value = minVal

    knob.MouseButton1Down:Connect(function()
        dragging = true
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)

    RunService.RenderStepped:Connect(function()
        if dragging then
            local mouseX = math.clamp(UserInputService:GetMouseLocation().X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X)
            fill.Size = UDim2.new(0, mouseX, 1, 0)
            knob.Position = UDim2.new(0, mouseX - knob.AbsoluteSize.X/2, 0, 0)
            value = minVal + (mouseX/slider.AbsoluteSize.X)*(maxVal-minVal)
        end
    end)
    return label, slider, function() return value end
end

local speedLabel, speedSlider, getSpeed = createSlider("Follow Speed: 0.15", 240, 0.05, 0.55)
local heightLabel, heightSlider, getHeight = createSlider("Follow Height: 1", 300, 1, 10)

--// Menu collapse/expand
local function collapseMenu()
    hitboxButton.Visible = false
    followButton.Visible = false
    flyButton.Visible = false
    noclipButton.Visible = false
    speedLabel.Visible = false
    speedSlider.Visible = false
    heightLabel.Visible = false
    heightSlider.Visible = false

    TweenService:Create(frame, TweenInfo.new(0.3), {Size=UDim2.new(0,200,0,30)}):Play()

    hitboxEnabled = false
    followEnabled = false
    flyEnabled = false
    noclipEnabled = false

    local function updateBtn(btn,state,name)
        btn.Text = name..(state and ": ON" or ": OFF")
        btn.BackgroundColor3 = state and Color3.fromRGB(0,200,0) or Color3.fromRGB(200,0,0)
    end
    updateBtn(hitboxButton, hitboxEnabled, "Hitbox")
    updateBtn(followButton, followEnabled, "Follow")
    updateBtn(flyButton, flyEnabled, "Fly")
    updateBtn(noclipButton, noclipEnabled, "NoClip")
end

local function expandMenu()
    hitboxButton.Visible = true
    followButton.Visible = true
    flyButton.Visible = true
    noclipButton.Visible = true
    speedLabel.Visible = true
    speedSlider.Visible = true
    heightLabel.Visible = true
    heightSlider.Visible = true

    TweenService:Create(frame, TweenInfo.new(0.3), {Size=UDim2.new(0,200,0,400)}):Play()
end

titleLabel.InputBegan:Connect(function(input)
    if input.UserInputType==Enum.UserInputType.MouseButton1 then
        local now = tick()
        if now - lastClickTime < 0.3 then
            if menuOpen then collapseMenu() else expandMenu() end
            menuOpen = not menuOpen
        end
        lastClickTime = now
    end
end)

--// Button logic
local function updateBtn(btn,state,name)
    btn.Text = name..(state and ": ON" or ": OFF")
    btn.BackgroundColor3 = state and Color3.fromRGB(0,200,0) or Color3.fromRGB(200,0,0)
end

hitboxButton.MouseButton1Click:Connect(function()
    hitboxEnabled = not hitboxEnabled
    updateBtn(hitboxButton, hitboxEnabled, "Hitbox")
end)
followButton.MouseButton1Click:Connect(function()
    followEnabled = not followEnabled
    updateBtn(followButton, followEnabled, "Follow")
end)
flyButton.MouseButton1Click:Connect(function()
    flyEnabled = not flyEnabled
    updateBtn(flyButton, flyEnabled, "Fly")
end)
noclipButton.MouseButton1Click:Connect(function()
    noclipEnabled = not noclipEnabled
    updateBtn(noclipButton, noclipEnabled, "NoClip")
end)

--// Hitbox update
local function updateHitbox(zombie)
    local hrp = zombie:FindFirstChild("HumanoidRootPart")
    local hum = zombie:FindFirstChildWhichIsA("Humanoid")
    if hrp and hum then
        if hitboxEnabled then
            local hb = zombie:FindFirstChild("ZombieHitbox")
            if not hb then
                hb = Instance.new("Part")
                hb.Name = "ZombieHitbox"
                hb.Anchored = true
                hb.CanCollide = false
                hb.Transparency = 0.5
                hb.BrickColor = BrickColor.new("Really red")
                hb.Parent = zombie
                hb.Touched:Connect(function(hit)
                    if hit.Parent:FindFirstChildWhichIsA("Tool") then
                        hum:TakeDamage(1)
                    end
                end)
            end
            hb.Size = hitboxSize
            hb.CFrame = hrp.CFrame
        else
            local existing = zombie:FindFirstChild("ZombieHitbox")
            if existing then existing:Destroy() end
        end
    end
end

RunService.RenderStepped:Connect(function()
    -- Update hitboxes
    for _,z in ipairs(zombieStorage:GetChildren()) do
        if z:IsDescendantOf(zombieStorage) then updateHitbox(z) end
    end

    -- Follow logic
    if followEnabled and humRoot then
        followSpeed = getSpeed()
        followOffset = getHeight()
        local closestZombie = nil
        local closestDist = math.huge
        for _, z in ipairs(zombieStorage:GetChildren()) do
            local hrp = z:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (hrp.Position - humRoot.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestZombie = hrp
                end
            end
        end
        if closestZombie then
            humRoot.CFrame = humRoot.CFrame:Lerp(
                CFrame.new(closestZombie.Position + Vector3.new(0,followOffset,0)),
                followSpeed
            )
        end
    end

    -- Fly & NoClip
    if flyEnabled and humRoot then
        if not bodyVel then
            bodyVel = Instance.new("BodyVelocity")
            bodyVel.MaxForce = Vector3.new(1e5,1e5,1e5)
            bodyVel.Parent = humRoot
        end
        if not bodyGyro then
            bodyGyro = Instance.new("BodyGyro")
            bodyGyro.MaxTorque = Vector3.new(1e5,1e5,1e5)
            bodyGyro.Parent = humRoot
        end
        local cam = workspace.CurrentCamera
        local dir = Vector3.new(0,0,0)
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then dir = dir + cam.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then dir = dir - cam.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then dir = dir - cam.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then dir = dir + cam.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then dir = dir + Vector3.new(0,1,0) end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then dir = dir - Vector3.new(0,1,0) end
        if dir.Magnitude>0 then dir = dir.Unit*flySpeed else dir = Vector3.new(0,0,0) end
        bodyVel.Velocity = dir
        bodyGyro.CFrame = CFrame.new(humRoot.Position, humRoot.Position + cam.CFrame.LookVector)
    else
        if bodyVel then bodyVel:Destroy(); bodyVel=nil end
        if bodyGyro then bodyGyro:Destroy(); bodyGyro=nil end
    end

    if noclipEnabled and char then
        for _,p in ipairs(char:GetDescendants()) do
            if p:IsA("BasePart") then p.CanCollide = false end
        end
    else
        for _,p in ipairs(char:GetDescendants()) do
            if p:IsA("BasePart") then p.CanCollide = true end
        end
    end
end)
